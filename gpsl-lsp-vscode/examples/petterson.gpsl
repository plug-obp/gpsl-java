exclusion  =! [] ! |a==2 && b==2|
noDeadlock =! G ¬|deadlock|

// Stronger than no deadlock - ensures conditional continuous progress
noLiveLock =! []( ¬(|a==1| ∨ |b==1|) ∨ <>(|a==2| ∨ |b==2|) )

// Critical section cannot be empty forever if someone wants in
noLiveLock1 = []( (|a==1| ∨ |b==1|) -> <> (|a==2| ∨ |b==2|) )

// recurrence: Alice or Bob will enter the critical section infinitely often, stronger than noLiveLock
recurrence =! []<> (|a==2| or |b==2|)

initialSafety =! ((|a==0| ∧ |b==0| ∧ !|dA| ∧ !|dB|) ->
                            []!(|a==2| ∧ |b==2|))

// If a process wants to enter (flag up), it will eventually get to the CS.
liveness   =! [](  (|a==1| -> <> |a==2|)
                 ∧ (|b==1| -> <> |b==2|))

//if a process wants to enter, it will eventually succeed (not just that it might succeed infinitely often).
starvationFreedom =! []<>(|a==1| -> <>|a==2|) ∧ []<>(|b==1| -> <>|b==2|)

// If the other process is idle (does not wish to enter its critical section),
// a waiting process should eventually succeed in entering the critical section.
// When A is waiting (a == 1) and B is not interested (dB == false),
// A must eventually enter its critical section (a == 2).
idling = let
            aIsWaiting          = |a==1|,
            bNotInterested      = |b==0|,
            aInCriticalSection  = |a==2|,
            bIsWaiting          = |b==1|,
            aNotInterested      = |a==0|,
            bInCriticalSection  = |b==2|
        in! G (  (( aIsWaiting ∧ bNotInterested)→ F aInCriticalSection)
                ∧(( bIsWaiting ∧ aNotInterested)→ F bInCriticalSection))

// Flags accurately reflect process state
flagConsistency =! []( (|a==1| ∨ |a==2|) ↔ |dA|) ∧ ( (|b==1| ∨ |b==2|) ↔ |dB|)

flagDiscipline = let
                    aliceFlagUP=|a==1|,
                    aliceCS = |a==2|,
                    bobFlagUP=|b==1|,
                    bobCS = |b==2|
                in! ([]   (aliceCS -> /*P*/ aliceFlagUP) //P is the past operator, currently unsupported
                        && (bobCS   -> /*P*/ bobFlagUP  ) )


// When turn favors A and both want in, A should enter first
priorityRespect = []( (|a==1| ∧ |b==1| ∧ |turn == 0|) -> (!|b==2| U |a==2|) ) ∧
                  []( (|a==1| ∧ |b==1| ∧ |turn == 1|) -> (!|a==2| U |b==2|) )

// Turn variable should reflect recent activity
turnConsistency = []( (|a==2| -> |turn == 0|) ∧ (|b==2| -> |turn == 1|) )

strictAlternation = []( (|a==1| ∧ |b==1|) ->
                      (|a==2| -> (!|b==2| U (|a==0| ∧ (!|a==2| U |b==2|)))) ∧
                      (|b==2| -> (!|a==2| U (|b==0| ∧ (!|b==2| U |a==2|)))) )

// Process B can overtake A at most once
boundedOvertaking = [](|a==1| -> (|b==2| U (|a==2| ∨ (|b==2| U |a==2|))))

criticalExit =! [](|a==2| -> <>|a==0|) ∧ [](|b==2| -> <>|b==0|)

noSpuriousWait =! [](|a==1| -> F(|a==2| ∨ !|dA|)) ∧ [](|b==1| -> F(|b==2| ∨ !|dB|))

// If A enters before B starts waiting, B should not overtake unfairly
entryOrder =! (
                    []( (|dA| ∧ !|dB|) -> (!|b==2| W |a==2|) )
                 ∧  []( (|dB| ∧ !|dA|) -> (!|a==2| W |b==2|) ) )

// A process cannot re-enter after exiting if the other is waiting
noReentry = let
        aliceCS      = |a==2|,
        bobCS        = |b==2|,
        aliceWaiting = |a==1|,
        bobWaiting   = |b==1|
    in! (
            []((aliceCS ∧ bobWaiting ∧ X|a==0|)→ X(!aliceCS U bobCS))
        ∧ []((bobCS ∧ aliceWaiting ∧ X|b==0|)→ X(!bobCS U aliceCS)))

// One process in CS doesn't block the other from preparing if it wants to
nonInterference =! (
        [](|a==2| ∧ |b==0| -> <>(|b==1| ∨ |b==0|))
    ∧   [](|b==2| ∧ |a==0| -> <>(|a==1| ∨ |a==0|)) )

// Processes eventually express interest if they can
// this requires a fairness assumption, otherwise either process could permanently decide not to raise its flag
eventualInterest =! ([]<>(|a==0| -> <>|a==1|) ∧ []<>(|b==0| -> <>|b==1|))

// Both processes cannot be waiting forever simultaneously
noMutualWaiting = <>[] (|a==1| ∧ |b==1|)

combinedSpec = exclusion && noDeadlock && liveness && idling //&& flagDiscipline


comprehensiveSpec =
    // Safety
    exclusion ∧
    flagConsistency ∧
    turnConsistency ∧
    initialSafety ∧

    // Liveness
    noDeadlock ∧
    noLiveLock ∧
    starvationFreedom ∧
    criticalExit ∧

    // Fairness
    boundedOvertaking ∧
    priorityRespect ∧
    idling ∧

    // Progress
    liveness ∧
    recurrence ∧
    nonInterference